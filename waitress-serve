#!/usr/bin/env python

"""
Runner for Waitress.

It's really little more than a lightweight wrapper around Waitress's
`waitress.serve()` function.
"""

import getopt
import re
import sys

import waitress


__version__ = '0.1.1'
__author__ = 'Keith Gaughan'
__email__ = 'k@stereochro.me'


RUNNER_PATTERN = re.compile(r"""
    ^
    (?P<module>
        [a-z_][a-z0-9_]*(?:\.[a-z_][a-z0-9_]*)*
    )
    :
    (?P<object>
        [a-z_][a-z0-9_]*
    )
    $
    """, re.I | re.X)


def parse_opts(argv, opt_map):
    long_opts = ['help']
    for opt, cast in opt_map.items():
        if cast is bool:
            long_opts.append(opt)
            long_opts.append('no-' + opt)
        else:
            long_opts.append(opt + '=')
    opts, args = getopt.getopt(argv, '', long_opts)
    kwargs = {}
    for opt, arg in opts:
        orig_opt = opt.lstrip('-')
        if orig_opt.startswith('no-'):
            opt, flag = orig_opt[3:], False
        else:
            opt, flag = orig_opt, True
        if opt == 'help':
            return {'help': True}, ()
        if opt not in opt_map:
            print >> sys.stderr, "Invalid option: %s" % orig_opt
            sys.exit(1)
        if opt_map[opt] is not bool:
            arg = opt_map[opt](arg)
        else:
            arg = flag
        kwargs[opt.replace('-', '_')] = arg
    return kwargs, args


def show_help(fh, opt_map):
    print >> fh, "Usage:"
    print >> fh, "    waitress-serve OPTS module:object\n"
    print >> fh, "Options:"
    print >> fh, "    --help"
    for opt, cast in sorted(opt_map.items()):
        if cast is bool:
            print >> fh, "    --[no-]%s" % opt
        else:
            print >> fh, "    --%s=%s" % (opt, cast.__name__)


def main():
    opt_map = {
        'host': str,
        'port': int,
        'threads': int,
        'url-scheme': str,
        'ident': str,
        'backlog': int,
        'recv-bytes': int,
        'send-bytes': int,
        'outbuf-overflow': int,
        'inbuf-overflow': int,
        'connection-limit': int,
        'cleanup-interval': int,
        'channel-timeout': int,
        'log-socket-errors': bool,
        'max-request-header-size': int,
        'max-request-body-size': int,
        'expose-tracebacks': bool,
        'call': bool,
    }
    kwargs, args = parse_opts(sys.argv[1:], opt_map)
    if 'help' in kwargs:
        show_help(sys.stdout, opt_map)
        return 0
    if len(args) != 1:
        print >> sys.stderr, 'Please specify one and only one application.'
        show_help(sys.stderr, opt_map)
        return 1
    matches = RUNNER_PATTERN.match(args[0])
    if not matches:
        print >> sys.stderr, "Malformed application: '%s'" % args[0]
        show_help(sys.stderr, opt_map)
        return 1

    module_name = matches.group('module')
    object_name = matches.group('object')

    module = __import__(module_name, fromlist=[object_name])
    app = getattr(module, object_name)
    if 'call' in kwargs and kwargs['call']:
        app = app()
        del kwargs['call']
    waitress.serve(app, **kwargs)
    return 0


if __name__ == '__main__':
    sys.exit(main())
